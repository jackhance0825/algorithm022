- 复杂度
    - 分析法则
        - 单段代码看高频：比如循环
        - 多段代码取最大
        - 嵌套代码求乘积
        - 多个规模求加法
    - 时间复杂度
        - 最好情况时间复杂度（best case time complexity）
        - 最坏情况时间复杂度（worst case time complexity）
        - 平均情况时间复杂度（average case time complexity）
        - 均摊时间复杂度（amortized time complexity）
    - 空间复杂度
    - 常用的复杂度级别
- 线性表
    - 数组
        - 连续的内存空间，存储相同类型的数据
        - 支持随机访问，时间复杂度O(1)，a[i]_address = base_address + i * data_type_size
        - ​低效的 "插入" 和 "删除"，时间复杂度O(n)，操作后需要数据的搬运
        - 危险的越界问题 java.lang.ArrayIndexOutOfBoundsException
        - ​容器是否可以完全替代数组？比如 Java 中的 ArrayList、C++ STL 中的 vector
    - 链表
        - 通过 "指针" 将零碎的内存块串联，内存块成为链表的结点
        - 插入删除操作时间复杂度O(1)，随机访问时间复杂度O(n)
        - 常见链表结构
            - 单链表​
                - 记录下个结点的指针，后继指针next
                - 首个结点是头结点，最后的结点为尾结点，尾结点指向空地址null
                - 插入和删除操作，不需要数据搬运，快速
                - 随机访问低效，需按指针依次遍历
            - 循环链表
                - 和单链表唯一区别，尾结点指向链表头结点
            - 双链表
                - 每个结点都有后继结点next & 前去结点prev，需要额外的空间存储指针
                - 支持双向遍历，空间换时间，实现如 LinkedHashMap
                    - 组合HashMap & double-end-list
                    - double-end-list
                        - insert order (default) 
                        - accessOrder（move to tail）
            - 双向循环链表
                - 和双链表唯一区别，尾结点的后继指针指向头结点，头结点的前驱指针指向尾结点
        - 链表 VS 数组
            - CPU缓存机制
                - 数组使用连续的内存空间，借助CPU缓存机制，预读，访问高效
                - 链表存储不连续，CPU缓存不友好，无法有效预读
            - 内存分配
                - 数组大小固定，一经声明占用整块连续内存空间，过大，系统无法分配，OOM；过小，不经用，扩容需要搬运数据
                - 链表大小没限制，天然支持动态扩容
            - 内存使用
                - 链表的后继指针消耗额外的存储空间
                - 链表频繁插入、删除，频繁内存申请与释放，容易造成内存碎片化，可能会导致频繁的GC
    - 队列
        - 先进先出，俩个最基本的操作：入队enqueue，出队dequeue
        - 用数组实现的队列叫顺序队列；用链表实现的队列叫链式队列；
        - 循环队列
            - 把数组首尾相连，形成环
            - 队空：head == tail
            - 队满：(tail + 1) % n == head
            - 缺点：tail指向位置没有存储数据，浪费1存储空间
        - 阻塞队列
            - 队列基础增加了阻塞操作，实现了 生产者-消费者模型
            - 队列为空时，队头取数据阻塞
            - 队列已满，插入数据阻塞
        - 并发队列
            - enqueue、dequeue加锁，同一时刻仅允许一个存或者取操作
        - 应用
            - 高性能Disruptor、Linux环形缓存，都用到了循环并发队列
            - ArrayBlockingQueue实现公平锁
    - 栈
        - 后进先出，实现如 Stack
        - 用数组实现的栈，叫顺序栈；
            - 入栈操作​
                - 最好情况时间复杂度O(1)
                - 最坏情况时间复杂度O(n)
                - 均摊时间复杂度O(1)
            - 出栈操作，时间复杂度O(1)
            - 底层依赖一个支持动态扩容的数组，栈满后，申请一个更大的数组，然后搬运数据
        - 用链表实现的栈，叫链式栈；
        - 应用
            - 函数调用
            - 表达式求值
            - 括号匹配
            - 浏览器前进、后退功能
- 散列表
    - 散列算法
        - 散列算法：任意长度二进制值串，映射成固定长度二进制串的规则
        - 散列值：映射后的二进制值串
        - 要求
            - 不能反向推导
            - 数据敏感
            - 不易冲突
            - 效率高
        - 应用
            - 安全加密，MD5、SHA
            - 唯一标识
            - 数据校验，电影分块下载
            - 散列函数
            - 负载均衡
            - 数据分片
            - 分布式存储，一致性哈希解决增减机器
    - 散列冲突
        - 开放寻址法
            - 数据存在在数据，利用CPU缓存加速
            - 冲突代价比链表法高，装载因子不能太大
            - ThreadLocalMap使用开放寻址法原因，数据量比较小，装载因子小，适合采用
        - 链表法
            - 适合存储大对象、大数据
            - 支持更多优化策略，比如HashMap红黑树代替链表
    - 动态扩容
        - 装载因子
            - 太大导致冲突过多
            - 太小导致内存浪费
        - 扩容效率，如何均摊O(1)？
    - 位图
- 树
    - 二叉树
        - 高度 & 深度 & 层
        - 存储
            - 基于指针或引用的二叉链式存储
            - 基于数组的顺序存储
        - 遍历方式
            - 前序遍历：根左右
            - 中序遍历：左根右
            - 后续遍历：左右根
            - BFS
            - DFS
        - 分类
            - 平衡二叉树
                - 树的高度接近logn
            - 二叉查找树BST
                - 特点：左子树的所有结点值 < 结点值 <= 右子树的所有结点值
            - 平衡二叉查找树
                - AVL
                    - balance factor = {-1, 0, 1}，右子树高度 - 左子树高度
                        - 
                    - 维持平衡的操作
                        - 
                - 红黑树
                    - 近似平衡的二叉搜索树
                    - 左右子树高度差倍数 = {0.5, 1, 2}
                    - 维持平衡方式同AVL
                    - 性质
                        - 每个结点非红即黑
                        - 根结点是黑
                        - 每个叶子(NIL)是黑色
                        - 不存在相邻的红色结点
                        - 从任意结点到其每个叶子结点的所有路径都包含相同数目的黑色结点
                        - 
                - AVL VS Red-black
                    - AVL trees provide faster lookups than Red Black Trees because they are more strictly balanced.
                    - Red Black Trees provide faster insertion and removal operations than AVL trees as fewer rotations are done due to relatively relaxed balancing.
                    - AVL trees store balance factors or heights with each node, thus requires storage for an integer per node whereas Red Black Tree requires only 1 bit of information per node.
                    - Red Black Trees are used in most of the language libraries likemap, multimap, multisetin C++ whereas AVL trees are used in databases where faster retrievals are required.
            - 完全二叉树
                - 叶子结点都在最底俩层，最后一层靠左，其他层结点达到最大
                - 高度小于等于log2n
            - 满二叉树：叶子结点全部在最底层
    - 堆
        - 操作
            - 建堆，时间复杂度O(n)
            - 插入，时间复杂度O(logn)
            - 删除，时间复杂度O(logn)
            - 堆化heapify，时间复杂度O(logn)
        - 分类
            - 小顶堆：每个节点的值都小于等于子树中每个节点值的堆
            - 大顶堆：每个节点的值都大于等于子树中每个节点值的堆
            - 优先队列
            - 斐波那契堆
            - 二项堆
        - 堆排序 VS 快排
            - 快排对CPU缓存更友好，快排顺序访问，堆排局部访问
            - 堆排序交换次数更多
        - 应用
            - 高性能定时器：使用优先队列，避免每次遍历任务列表
            - 求Top K：维护一个K大小的小顶堆，新数据只需和栈顶元素比对，时间复杂度为O(nlogK)
            - 求中位数：一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据
    - 多路查找树
        - B树
            - 特点
                - 根节点至少有两个孩子节点
                - 每个节点有M-1个关键字key（节点中的每一个元素叫关键字），并且以升序排列
                - 除去叶子节点和根节点其它节点至少有M/2个孩子节点
            - 应用
                - 查找磁盘地址（降低了树的高度，减少了IO查询次数）
            - 3阶（M = 3）B树
        - B+树
            - 特点
                - 非叶子结点的子树指针个数与关键字（节点中的元素个数）个数相同
                - 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）
                - 所有叶子结点有一个链指针
                - 所有关键字都在叶子结点出现
                - 只有叶子节点有Data域
            - 应用：mysql的Innodb存储引擎使用B+作为索引
                - 相比AVL、Red-Black，高度更低，IO操作次数更少
                - 相比hash，hash无法范围查找
                - 相比B树，因B树每个结点有Data，所以相同大小，B+树索引更多；范围查找，B树要通过下限起的中序遍历，B+树存在链表
            - 
        - 2-3树
            - 2代表一个节点有两个孩子，3代表一个节点有三个孩子。
            - 2-3树是一种绝对平衡树。它的节点的元素个数可以为1个或2个。
            - 
        - 2-3-4树
            - 2代表一个节点有两个孩子，3代表一个节点有三个孩子，4代表一个结点有四个孩子。
            - 它的节点元素个数可以为1、2、3；
            - 
- 图
    - 图的存储
        - 邻接矩阵
        - 邻接表
    - 拓扑排序
    - 最短路径 Dijkstra
    - 关键路径
    - 最小生成树
    - 二分图
    - 最大流
- 搜索
    - 深度优先搜索DFS
    - 广度优先搜索BFS
        - 应用： 最少步数
    - 双向BFS
        - 起点和终点俩端同时BFS，状态空间比BFS更小，效率更高
    - 启发式搜索
        - A*
            - 思想
                - 将问题抽象成有向有权图
                - BFS & PriorityQueue & 估价函数heuristic
            - 估价函数是关键
                - 估值 = 当前代价 + 目标代价
                - 流行的估价方式
                    - 相似 Similarity
                        - 海明相似 hamming：可用于比较俩个字符串相似度，同角标字符不同，则+1
                        - 余弦相似 Cosine Similarity
                            - 
                        - 贾卡德相似 Jaccard Similarity
                            - Jaccard Similarity = (A ∩ B) / (A ∪ B)
                    - 距离 distance
                        - 欧几里得距离 Euclidean distance
                            - distance = sqrt(sum(pow(a-b,2) for a, b in zip(x, y)))
                        - 曼哈顿距离 Manhattan distance
                            - Manhattan distance = |x1 – x2| + |y1 – y2|
                        - 明可夫斯基距离 Minkowski distance
                            - 
            - A* VS Dijkstra
                - A*的优先队列的估值（当前代价 + 目标代价），Dijkstra的优先队列估值（当前代价）
                - A*计算的是次优解（贪心），Dijkstra是最优解
                - 顶点生命周期不一样，A*是全局，Dijkstra是出队列就结束
        - IDA*
        - 蚁群
        - 遗传
        - 模拟退火
    - 二分查找
        - mid = left + (right - left) / 2
        - 前提
            - 数据单调
            - 存在上下界
            - 能索引访问，依赖数组
            - 数据量太少（顺序更优）、太大（内存连续，苛刻）都不合适
        - 常见问题
            - 查找第一个值等于给定值的元素
            - 查找最后一个值等于给定值的元素
- 思想
    - 分治：分割大问题，分批处理，合并结果，返回
        - 应用
            - MapReduce
    - 回溯：采用试错思想，通常采用递归，反复重复，分步解决问题
        - 最坏情况时间复杂度为指数
    - 贪心：追求当前最优，求证最优子结构即全局最优，不能回溯
        - 应用不多，一般辅助，一旦能贪心，那么贪心即最优
        - 应用
            - 最小生成树
            - 哈夫曼树
    - 动态规划
        - 一个模型三个特征
            - 最优子结构：子问题最优解可以推导问题的最优解
            - 无后效性
                - 推导后续状态，只关心前状态值，不关心状态值的由来
                - 状态一旦确定，不受后续决策影响
            - 重复子问题
            - 多阶段决策模型：经历多个决策阶段，每个阶段对应一组状态，最终推导问题的最优解
        - 解决步骤
            - 定义子问题
            - 猜部分方法
            - 连接子问题的方法
            - 递归 & 记忆化 或者 自底向上递推
- 字典树 Trie
    - 应用
        - 统计字符串频次
    - 思想
        - 最大限度减少无谓的字符串比较，查询效率比哈希表高
        - 空间换时间
        - 利用公共前缀来降低查询时间，以达到提高效率的目的
    - 使用要求
        - 字符集不能太大，否则会浪费过多空间
        - 要求字符串前缀重合度较多
        - 指针串起来的数据块不连续，对CPU缓存不友好
    - 实现
- 并查集
    - 应用
        - 组团、匹配
    - 操作
        - 构建
        - 合并
        - 查 & 路径压缩
- 跳表
    - 空间换时间（空间复杂度O(n)），基于链表的二分查找，CRUD时间复杂度O(logn)
    - 索引节点只存储关键值和指针，不存储对象
    - 
- 排序
    - 比较类排序
        - 交换排序
            - 冒泡排序 (n ^ 2， 稳定)
                - 
            - 快速排序(n logn)
                - 
        - 插入排序
            - 简单插入排序 (n ^ 2, 稳定)
                - 
            - 希尔排序 (n ^ 1.3)， 优先比较距离较远的元素，缩小增量排序
                - 
        - 选择排序
            - 简单选择排序 (n ^ 2)
                - 
            - 堆排序 (n logn)
                - 
        - 归并排序
            - 二路归并排序(n logn，稳定)
                - 
            - 多路归并排序 (n logn，稳定)
    - 非比较类排序
        - 计数排序 (n + k，稳定)
            - 
        - 桶排序 (n，稳定)
            - 
        - 基数排序 (n * k，稳定)
            - 
- 位运算
    - XOR
        - x ^ 0 = x
        - x ^ (~0) = ~x
        - x ^ (-x) = ~0
        - x ^ x = 0
        - swap
    - 将x最右的n位清零：x & (~0 << n)
    - 获取x的第n位值：(x >> n) & 1
    - 获取x的第n位幂值：x & (1 << n)
    - 仅将第n位置1：x | (1 << n)
    - 仅将第n位置0：x | (~1 << n)
    - 将x最高位至第n位（include）清零：x & ((1 << n) - 1)
    - 奇偶数判定，奇：x & 1 == 1；偶：x & 1 == 0
    - 去除最低位的1：x & x - 1
    - 获取最低位的1：x & -x
    - x & -x = 0
- 布隆过滤器
    - 原理：一个很长的二进制向量和一系列的随机映射函数。用于检索元素是否在集合中
        - 
    - 关键点：
        - 错误率
        - 哈希函数个数
        - 位数组的大小
    - 场景
        - 缓存击穿
        - 垃圾邮件识别
        - 集合判重
- 缓存
    - FIFO
    - LRU（Least recently used）
        - 思想：刚visit的item,很有可能在未来被revisit
        - 实现方式：双向链表，丢弃最近最少访问的items
    - LFU（Least-frequently used）
        - 思想：visit次数越多的item,很有可能在未来被revisit
        - 实现方式：双向链表 & hashMap，访问频次 > 最近访问时间
    - ARC (Adaptive replacement cache)
        - 思想：LRU和LFU的动态平衡，初始各占一半，后续动态调整
        - 实现方式：LRU和LFU各有一个ghost list（记录移除的数据），cache miss & in ghost，增大对应空间
- 字符串
    - 单模式串
        - 朴素（BF）
        - RK
            - 朴素 + hash
        - BM
            - 坏字符 + 好后缀子串，从后开始匹配
        - KMP
            - next数组，最长前缀
    - 多模式串
        - AC自动机
            - Trie + kmp
        - Trie
